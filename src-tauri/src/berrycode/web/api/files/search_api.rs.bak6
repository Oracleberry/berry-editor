//! File search API

use axum::{
    extract::{Query, State},
    http::StatusCode,
    Json,
};
use serde::{Deserialize, Serialize};
use std::fs;
use walkdir::WalkDir;
use regex::Regex;

use crate::berrycode::berrycode::web::infrastructure::session_db::SessionDbStore;

/// Search API state
#[derive(Clone)]
pub struct SearchApiState {
    pub session_store: SessionDbStore,
}

/// Search query
#[derive(Debug, Deserialize)]
pub struct SearchQuery {
    pub session_id: String,
    pub query: String,
    pub regex: Option<bool>,
    pub case_sensitive: Option<bool>,
}

/// Search result
#[derive(Debug, Serialize)]
pub struct SearchResult {
    pub file: String,
    pub line_number: usize,
    pub line_content: String,
    pub matches: Vec<SearchMatch>,
}

/// Search match
#[derive(Debug, Serialize)]
pub struct SearchMatch {
    pub start: usize,
    pub end: usize,
}

/// Search in files
pub async fn search_files(
    Query(query): Query<SearchQuery>,
    State(state): State<SearchApiState>,
) -> Result<Json<Vec<SearchResult>>, StatusCode> {
    // Get session
    let session = state
        .session_store
        .get_session(&query.session_id)
        .await
        .ok_or(StatusCode::NOT_FOUND)?;

    let mut results = Vec::new();
    let case_sensitive = query.case_sensitive.unwrap_or(false);
    let use_regex = query.regex.unwrap_or(false);

    // Compile regex if needed
    let regex = if use_regex {
        Some(
            Regex::new(&query.query)
                .map_err(|_| StatusCode::BAD_REQUEST)?,
        )
    } else {
        None
    };

    // Walk directory
    for entry in WalkDir::new(&session.project_root)
        .follow_links(false)
        .max_depth(10)
        .into_iter()
        .filter_entry(|e| {
            let name = e.file_name().to_string_lossy();
            !name.starts_with('.') &&
            name != "node_modules" &&
            name != "target" &&
            name != "dist"
        })
    {
        let entry = match entry {
            Ok(e) => e,
            Err(_) => continue,
        };

        if !entry.file_type().is_file() {
            continue;
        }

        // Skip binary files (simple check)
        let path = entry.path();
        if let Some(ext) = path.extension() {
            let ext_str = ext.to_string_lossy();
            if matches!(ext_str.as_ref(), "exe" | "dll" | "so" | "dylib" | "png" | "jpg" | "jpeg" | "gif" | "pdf" | "zip") {
                continue;
            }
        }

        // Read file and search
        if let Ok(content) = fs::read_to_string(path) {
            for (line_num, line) in content.lines().enumerate() {
                let matches = if let Some(ref re) = regex {
                    // Regex search
                    let found_matches: Vec<_> = re
                        .find_iter(line)
                        .map(|m| SearchMatch {
                            start: m.start(),
                            end: m.end(),
                        })
                        .collect();

                    if found_matches.is_empty() {
                        continue;
                    }
                    found_matches
                } else {
                    // Simple text search
                    let search_line = if case_sensitive {
                        line.to_string()
                    } else {
                        line.to_lowercase()
                    };

                    let search_query = if case_sensitive {
                        query.query.clone()
                    } else {
                        query.query.to_lowercase()
                    };

                    if !search_line.contains(&search_query) {
                        continue;
                    }

                    // Find all occurrences
                    let mut found_matches = Vec::new();
                    let mut start_pos = 0;

                    while let Some(pos) = search_line[start_pos..].find(&search_query) {
                        let actual_pos = start_pos + pos;
                        found_matches.push(SearchMatch {
                            start: actual_pos,
                            end: actual_pos + search_query.len(),
                        });
                        start_pos = actual_pos + 1;
                    }

                    found_matches
                };

                let relative_path = path
                    .strip_prefix(&session.project_root)
                    .unwrap_or(path)
                    .to_string_lossy()
                    .to_string();

                results.push(SearchResult {
                    file: relative_path,
                    line_number: line_num + 1,
                    line_content: line.to_string(),
                    matches,
                });

                // Limit results
                if results.len() >= 1000 {
                    return Ok(Json(results));
                }
            }
        }
    }

    Ok(Json(results))
}

/// File name search (quick file finder)
pub async fn search_file_names(
    Query(query): Query<SearchQuery>,
    State(state): State<SearchApiState>,
) -> Result<Json<Vec<String>>, StatusCode> {
    // Get session
    let session = state
        .session_store
        .get_session(&query.session_id)
        .await
        .ok_or(StatusCode::NOT_FOUND)?;

    let mut results = Vec::new();
    let query_lower = query.query.to_lowercase();

    // Walk directory
    for entry in WalkDir::new(&session.project_root)
        .follow_links(false)
        .max_depth(10)
        .into_iter()
        .filter_entry(|e| {
            let name = e.file_name().to_string_lossy();
            !name.starts_with('.') &&
            name != "node_modules" &&
            name != "target" &&
            name != "dist"
        })
    {
        let entry = match entry {
            Ok(e) => e,
            Err(_) => continue,
        };

        if !entry.file_type().is_file() {
            continue;
        }

        let file_name = entry
            .file_name()
            .to_string_lossy()
            .to_lowercase();

        if file_name.contains(&query_lower) {
            let relative_path = entry
                .path()
                .strip_prefix(&session.project_root)
                .unwrap_or(entry.path())
                .to_string_lossy()
                .to_string();

            results.push(relative_path);

            if results.len() >= 100 {
                break;
            }
        }
    }

    Ok(Json(results))
}

/// Definition location
#[derive(Debug, Serialize)]
pub struct DefinitionLocation {
    pub file: String,
    pub line_number: usize,
    pub column: usize,
    pub line_content: String,
}

/// Search for symbol definition (for Cmd+Click navigation)
pub async fn search_definition(
    Query(query): Query<SearchQuery>,
    State(state): State<SearchApiState>,
) -> Result<Json<Vec<DefinitionLocation>>, StatusCode> {
    // Get session
    let session = state
        .session_store
        .get_session(&query.session_id)
        .await
        .ok_or(StatusCode::NOT_FOUND)?;

    let symbol = &query.query;
    let mut results = Vec::new();

    // Define patterns for different languages
    let patterns = vec![
        // Rust: fn foo, struct Foo, impl Foo, trait Foo, enum Foo
        format!(r"\b(fn|struct|enum|trait|impl|type|const|static)\s+{}\b", regex::escape(symbol)),
        // JavaScript/TypeScript: function foo, class Foo, const foo =
        format!(r"\b(function|class|const|let|var|interface|type)\s+{}\b", regex::escape(symbol)),
        // Python: def foo, class Foo
        format!(r"\b(def|class)\s+{}\b", regex::escape(symbol)),
        // Go: func foo, type Foo
        format!(r"\b(func|type)\s+{}\b", regex::escape(symbol)),
    ];

    // Walk directory
    for entry in WalkDir::new(&session.project_root)
        .follow_links(false)
        .max_depth(10)
        .into_iter()
        .filter_entry(|e| {
            let name = e.file_name().to_string_lossy();
            !name.starts_with('.') &&
            name != "node_modules" &&
            name != "target" &&
            name != "dist"
        })
    {
        let entry = match entry {
            Ok(e) => e,
            Err(_) => continue,
        };

        if !entry.file_type().is_file() {
            continue;
        }

        // Check if file extension is a code file
        let path = entry.path();
        let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");
        if !matches!(ext, "rs" | "js" | "ts" | "jsx" | "tsx" | "py" | "go" | "java" | "c" | "cpp" | "h" | "hpp") {
            continue;
        }

        // Read file and search for definition
        if let Ok(content) = fs::read_to_string(path) {
            for (line_num, line) in content.lines().enumerate() {
                // Try each pattern
                for pattern_str in &patterns {
                    if let Ok(re) = Regex::new(pattern_str) {
                        if let Some(mat) = re.find(line) {
                            let relative_path = path
                                .strip_prefix(&session.project_root)
                                .unwrap_or(path)
                                .to_string_lossy()
                                .to_string();

                            results.push(DefinitionLocation {
                                file: relative_path,
                                line_number: line_num + 1,
                                column: mat.start(),
                                line_content: line.to_string(),
                            });

                            // Return first match (most likely the definition)
                            if !results.is_empty() {
                                return Ok(Json(results));
                            }
                        }
                    }
                }
            }
        }
    }

    Ok(Json(results))
}
