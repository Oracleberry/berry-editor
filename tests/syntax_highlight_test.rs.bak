//! Syntax Highlighting Tests - 100% Coverage

use berry_editor::syntax::{SyntaxHighlighter, TokenType};
use wasm_bindgen_test::*;

wasm_bindgen_test_configure!(run_in_browser);

// ========== Basic Functionality Tests ==========

#[wasm_bindgen_test]
fn test_highlighter_initialization() {
    let highlighter = SyntaxHighlighter::new();
    assert!(highlighter.get_language().is_none());
}

#[wasm_bindgen_test]
fn test_set_language_rust() {
    let mut highlighter = SyntaxHighlighter::new();
    assert!(highlighter.set_language("rust").is_ok());
    assert_eq!(highlighter.get_language(), Some("rust"));
}

#[wasm_bindgen_test]
fn test_set_language_javascript() {
    let mut highlighter = SyntaxHighlighter::new();
    assert!(highlighter.set_language("javascript").is_ok());
    assert_eq!(highlighter.get_language(), Some("javascript"));
}

#[wasm_bindgen_test]
fn test_set_language_python() {
    let mut highlighter = SyntaxHighlighter::new();
    assert!(highlighter.set_language("python").is_ok());
    assert_eq!(highlighter.get_language(), Some("python"));
}

// ========== Rust Highlighting Tests ==========

#[wasm_bindgen_test]
fn test_rust_keyword_highlighting() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("rust").unwrap();

    let tokens = highlighter.highlight_line("fn main() {");
    let has_fn_keyword = tokens.iter().any(|t| {
        t.token_type == TokenType::Keyword && t.text == "fn"
    });
    assert!(has_fn_keyword, "Should highlight 'fn' as keyword");
}

#[wasm_bindgen_test]
fn test_rust_let_keyword() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("rust").unwrap();

    let tokens = highlighter.highlight_line("let x = 5;");
    let has_let = tokens.iter().any(|t| {
        t.token_type == TokenType::Keyword && t.text == "let"
    });
    assert!(has_let);
}

#[wasm_bindgen_test]
fn test_rust_type_highlighting() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("rust").unwrap();

    let tokens = highlighter.highlight_line("let s: String = String::new();");
    let string_types = tokens.iter().filter(|t| {
        t.token_type == TokenType::Type && t.text == "String"
    }).count();
    assert!(string_types >= 1, "Should highlight 'String' as type");
}

#[wasm_bindgen_test]
fn test_rust_comment_highlighting() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("rust").unwrap();

    let tokens = highlighter.highlight_line("// This is a comment");
    assert_eq!(tokens.len(), 1);
    assert_eq!(tokens[0].token_type, TokenType::Comment);
    assert!(tokens[0].text.starts_with("//"));
}

#[wasm_bindgen_test]
fn test_rust_inline_comment() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("rust").unwrap();

    let tokens = highlighter.highlight_line("let x = 5; // inline comment");
    let has_keyword = tokens.iter().any(|t| t.token_type == TokenType::Keyword);
    let has_comment = tokens.iter().any(|t| t.token_type == TokenType::Comment);
    assert!(has_keyword && has_comment);
}

#[wasm_bindgen_test]
fn test_rust_number_detection() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("rust").unwrap();

    let tokens = highlighter.highlight_line("let x = 42;");
    let has_number = tokens.iter().any(|t| t.token_type == TokenType::Number);
    assert!(has_number, "Should detect numbers");
}

#[wasm_bindgen_test]
fn test_rust_uppercase_type_detection() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("rust").unwrap();

    let tokens = highlighter.highlight_line("MyCustomType");
    let has_custom_type = tokens.iter().any(|t| {
        t.token_type == TokenType::Type && t.text == "MyCustomType"
    });
    assert!(has_custom_type);
}

// ========== JavaScript Highlighting Tests ==========

#[wasm_bindgen_test]
fn test_javascript_comment() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("javascript").unwrap();

    let tokens = highlighter.highlight_line("// JavaScript comment");
    assert_eq!(tokens.len(), 1);
    assert_eq!(tokens[0].token_type, TokenType::Comment);
}

#[wasm_bindgen_test]
fn test_javascript_keywords() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("javascript").unwrap();

    let tokens = highlighter.highlight_line("function test() {");
    let has_function = tokens.iter().any(|t| {
        t.token_type == TokenType::Keyword && t.text == "function"
    });
    assert!(has_function);
}

// ========== Python Highlighting Tests ==========

#[wasm_bindgen_test]
fn test_python_comment() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("python").unwrap();

    let tokens = highlighter.highlight_line("# Python comment");
    assert_eq!(tokens.len(), 1);
    assert_eq!(tokens[0].token_type, TokenType::Comment);
}

#[wasm_bindgen_test]
fn test_python_keywords() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("python").unwrap();

    let tokens = highlighter.highlight_line("def test():");
    let has_def = tokens.iter().any(|t| {
        t.token_type == TokenType::Keyword && t.text == "def"
    });
    assert!(has_def);
}

// ========== TokenType Tests ==========

#[wasm_bindgen_test]
fn test_token_type_colors() {
    assert_eq!(TokenType::Keyword.to_color(), "#569cd6");
    assert_eq!(TokenType::Function.to_color(), "#dcdcaa");
    assert_eq!(TokenType::Type.to_color(), "#4ec9b0");
    assert_eq!(TokenType::String.to_color(), "#ce9178");
    assert_eq!(TokenType::Number.to_color(), "#b5cea8");
    assert_eq!(TokenType::Comment.to_color(), "#6a9955");
    assert_eq!(TokenType::Operator.to_color(), "#d4d4d4");
    assert_eq!(TokenType::Identifier.to_color(), "#9cdcfe");
}

#[wasm_bindgen_test]
fn test_token_type_classes() {
    assert_eq!(TokenType::Keyword.as_class(), "syntax-keyword");
    assert_eq!(TokenType::Function.as_class(), "syntax-function");
    assert_eq!(TokenType::Type.as_class(), "syntax-type");
    assert_eq!(TokenType::String.as_class(), "syntax-string");
    assert_eq!(TokenType::Number.as_class(), "syntax-number");
    assert_eq!(TokenType::Comment.as_class(), "syntax-comment");
    assert_eq!(TokenType::Operator.as_class(), "syntax-operator");
    assert_eq!(TokenType::Identifier.as_class(), "syntax-identifier");
}

// ========== Edge Cases ==========

#[wasm_bindgen_test]
fn test_empty_line() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("rust").unwrap();

    let tokens = highlighter.highlight_line("");
    // Empty line may return empty tokens or a single identifier token
    assert!(tokens.is_empty() || (tokens.len() == 1 && tokens[0].text.is_empty()));
}

#[wasm_bindgen_test]
fn test_whitespace_only_line() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("rust").unwrap();

    let tokens = highlighter.highlight_line("    ");
    // Should handle whitespace gracefully
    assert!(tokens.len() >= 0);
}

#[wasm_bindgen_test]
fn test_no_language_set() {
    let highlighter = SyntaxHighlighter::new();
    let tokens = highlighter.highlight_line("some text");
    assert_eq!(tokens.len(), 1);
    assert_eq!(tokens[0].token_type, TokenType::Identifier);
}

#[wasm_bindgen_test]
fn test_multiple_keywords_same_line() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("rust").unwrap();

    let tokens = highlighter.highlight_line("pub fn test() -> impl Iterator");
    let keyword_count = tokens.iter().filter(|t| t.token_type == TokenType::Keyword).count();
    assert!(keyword_count >= 2, "Should find multiple keywords");
}

#[wasm_bindgen_test]
fn test_mixed_case_identifiers() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("rust").unwrap();

    let tokens = highlighter.highlight_line("MyStruct vs my_function");
    let has_type = tokens.iter().any(|t| t.token_type == TokenType::Type && t.text == "MyStruct");
    assert!(has_type, "CamelCase should be recognized as type");
}

// ========== Default Implementation Test ==========

#[wasm_bindgen_test]
fn test_default_implementation() {
    let highlighter = SyntaxHighlighter::default();
    assert!(highlighter.get_language().is_none());
}

// ========== Complex Code Tests ==========

#[wasm_bindgen_test]
fn test_complex_rust_line() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("rust").unwrap();

    let tokens = highlighter.highlight_line("pub async fn process_data(input: Vec<String>) -> Result<(), Error> {");

    let has_pub = tokens.iter().any(|t| t.token_type == TokenType::Keyword && t.text == "pub");
    let has_async = tokens.iter().any(|t| t.token_type == TokenType::Keyword && t.text == "async");
    let has_fn = tokens.iter().any(|t| t.token_type == TokenType::Keyword && t.text == "fn");
    let has_vec = tokens.iter().any(|t| t.token_type == TokenType::Type && t.text == "Vec");
    let has_result = tokens.iter().any(|t| t.token_type == TokenType::Type && t.text == "Result");

    assert!(has_pub && has_async && has_fn && has_vec && has_result,
        "Should highlight all tokens in complex line");
}

#[wasm_bindgen_test]
fn test_string_handling() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("rust").unwrap();

    let tokens = highlighter.highlight_line(r#"let s = "hello world";"#);
    let has_string = tokens.iter().any(|t| t.token_type == TokenType::String);
    assert!(has_string, "Should detect strings");
}

// ========== Performance Test ==========

#[wasm_bindgen_test]
fn test_highlighting_performance() {
    let mut highlighter = SyntaxHighlighter::new();
    highlighter.set_language("rust").unwrap();

    let long_line = "let x = 1; ".repeat(100); // 1100 chars

    let start = web_sys::window()
        .unwrap()
        .performance()
        .unwrap()
        .now();

    let _tokens = highlighter.highlight_line(&long_line);

    let elapsed = web_sys::window()
        .unwrap()
        .performance()
        .unwrap()
        .now() - start;

    // Should complete in reasonable time (< 50ms)
    assert!(elapsed < 50.0, "Highlighting should be fast, took {}ms", elapsed);
}

// ========== Clone and PartialEq Tests ==========

#[wasm_bindgen_test]
fn test_token_type_equality() {
    assert_eq!(TokenType::Keyword, TokenType::Keyword);
    assert_ne!(TokenType::Keyword, TokenType::Type);
}

#[wasm_bindgen_test]
fn test_token_type_clone() {
    let token_type = TokenType::Keyword;
    let cloned = token_type.clone();
    assert_eq!(token_type, cloned);
}
